import java.util.*;
/*
Код блокировки мобильных телефонов не умеют взламывать даже спецслужбы, однако хакерская группировка Анонимусы-80 добралась до исходников операционной системы, и выяснила способ его почти мгновенного взлома.

Оказывается, достаточно лишь посчитать длину линии, рисуемой в процессе взлома кода, после чего округлить её до пятого знака, и нажать пальцем на соответствующие цифры, пропуская нули, как телефон разблокируется.

Раскладка точек блокировки:



Ломаная линия разблокировки представляет собой последовательность цифр от 1 до 9, соответствующих точкам на этой картинке, причем гарантируется, что от точки переход совершается только к её ближайшим соседям (нету перепрыгиваний, например из точки 8 в точку 5).
Расстояние между точками по вертикали или горизонтали считается единичным.

На рисунке представлена такая последовательность: 1 2 3 4 5 6 2 7 8 9

Её длина приблизительно равняется 1 + 1 + 1 + 1 + 1 + 1.41.. + 1.41.. + 1 + 1 = 9.82843
(точность требуется пять цифр после запятой)

Результат: строка "982843"

Если бы результат получился, например, 10.012, то результирующая строка получилась бы "112" (все нули удаляются).

Функция

string PatternUnlock(int N, int [] hits) 
получает параметром N длину массива с кодами разблокировки, а сам массив hits содержит последовательность кодов разблокировки -- номера точек в диапазоне от 1 до 9.
Последовательность задаётся только шагами между соседними точками, программно искать "длинные" пути не нужно.
Серые линии на рисунке -- просто пример возможной траектории.
Возвращает функция строку, как в примере выше.
*/

public class Level1{
	public static String PatternUnlock(int N, int[] hits) {

		List<Integer> intListDiagonal = Arrays.asList(4, 6, 7, 9);
		float[] summa = new float[N];
		float diagonal = 1.414215f;
		float odin = 1;
		char diagonalMatch = 'G';
		char vertMatch = 'V';
		char dva = '2';
		char[] charsArray = new char[hits.length];
		float value1 = 0;


		for (int i = 0; i < hits.length; i++) {
			if (hits[i] == 2) {
				charsArray[i] = dva;
			} else if (intListDiagonal.contains(hits[i]) == true) {
				charsArray[i] = diagonalMatch;
			} else {
				charsArray[i] = vertMatch;
			}
		}

		for (int k = 0; k < charsArray.length; k++) {
			if (k == 0) {
				continue;
			} else if (charsArray[k - 1] == '2' && charsArray[k] == 'G' ||
					charsArray[k - 1] == 'G' && charsArray[k] == '2') {
				summa[k - 1] = diagonal;
			} else {
				summa[k - 1] = odin;
			}
		}

		for (int j = 0; j < summa.length; j++) {
			value1 += summa[j];
		}

		int number = (int) (value1 * 100000);
		int number1 = Integer.parseInt(Integer.toString(number).replace("0", ""));

		String str = String.valueOf(number1);
		return str;
	}

}
