import java.util.*;
/**
 * Оптимизация беспилотного трафика
Яндекс выпускает на улицы тысячи беспилотных автомобилей, и теперь появляется отличная возможность оптимизации трафика на дорогах. Прежде всего требуется точно оценить время прибытия машины в место назначения.

На дороге автомобиль постоянно встречает светофоры, которые горят либо зелёным, либо красным. Время горения зелёного и красного света задаётся в секундах. Цикл переключения цветов повторяется бесконечно и начинается с красного цвета.

Так как скорость автомобиля известна, положения светофоров на дороге определяются временем, которое требуется, чтобы доехать до этого светофора из начала дороги при условии, что все предыдущие светофоры горят зелёным.

Каждый светофор также характеризуется временем горения красного и зелёного цвета.

Задача -- определить, за какое время автомобиль доберётся до конца дороги.

Например, имеется дорога длиной 10 единиц времени. Первый светофор расположен на отметке 3 единицы времени и характеризуется циклом 5 красный 5 зелёный. Второй светофор расположен на отметке 5, и время показа красного и зелёного для него 2 и 2.

Автомобиль стартует, через 3 единицы добирается до первого светофора, на котором горит красный. Он горит 5 единиц, то есть движение начинается с 5-го момента.

Через две единицы автомобиль добирается до второго светофора -- это абсолютный момент 7. В этот момент на светофоре горит зелёный, и автомобиль проезжает его без остановки. От второго светофора до конца дороги остаётся ещё 5 моментов, таким образом суммарное время автомобиля в пути равно 12 (7 + 5).

Функция

int Unmanned(int L, int N, int [][3] track)
получает на вход длину L дороги, количество светофоров на ней N, и описание самой дороги, где каждый элемент состоит из трёх значений: момент времени относительно начала дороги (когда в него прибудет автомобиль по свободной дороге), время показа красного света и время показа зелёного цвета.
Для примера выше параметры функции Unmanned() будут такими: 10, 2, [ [3,5,5], [5,2,2] ]

Функция возвращает реальное время, требуемое для преодоления дороги.
*/

public class Level1{
	public static int Unmanned(int L, int N, int [][] track) {
		int otDoLight = 0;
		int result = 0;
		int trafficLight = 0;
		//время светофора
		int summaLight = 0;
		//свет светофора
		boolean red = true;
		//секунды светофора
		int summaRed = 0;
		int timeTest = 0;

		if (L <= track[0][0]) {
			return L;
		}

		//идем циклом по светофорам
		for (int i = 0; i < N; i++) {
			if (i == 0) {
				otDoLight += track[trafficLight][0];
			} else if (trafficLight <= N - 1 && track[trafficLight][0] <= L) {
				//вычисляем время между светофорами
				otDoLight += track[trafficLight][0] - track[trafficLight - 1][0];
			}

			//вычисляем свет светофора
			for (int k = 0; k <= otDoLight; k++) {
				//добавляем секунды светофора
				if (red) {
					summaLight += track[trafficLight][1];
					red = false;
					k += track[trafficLight][1];
				} else {
					summaLight += track[trafficLight][2];
					red = true;
					k +=  track[trafficLight][2];
				}
				//если секунды больше или равно time
				if (summaLight >= otDoLight && red){
					red = false;
				} else
				if (summaLight >= otDoLight){
					red = true;
				}

			}
			//считаем время красного горения
			if (red) {
				summaRed += Math.abs(otDoLight - summaLight);
				timeTest += summaRed;
				summaRed = 0;

			}
			summaLight = 0;
			if (otDoLight < L && trafficLight == N - 1 || track[trafficLight][0] > L) {
				timeTest += L - otDoLight;
			}
			otDoLight += timeTest;
			trafficLight++;
		}
		result += otDoLight;
		return  result;
	}
}
